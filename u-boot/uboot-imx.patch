diff -Naur u-boot-imx/board/architech/tibidabo/1066mhz_4x256mx16.cfg modificato-u-boot-imx/board/architech/tibidabo/1066mhz_4x256mx16.cfg
--- u-boot-imx/board/architech/tibidabo/1066mhz_4x256mx16.cfg	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/1066mhz_4x256mx16.cfg	2015-02-03 17:00:46.059786300 +0100
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ */
+DATA 4, MX6_MMDC_P0_MDPDC,       0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0,      0x898E7974
+DATA 4, MX6_MMDC_P0_MDCFG1,      0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2,      0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD,       0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR,        0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC,       0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC,       0x00025576
+DATA 4, MX6_MMDC_P0_MDASP,       0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL,       0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR,       0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR,       0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR,       0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR,       0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR,       0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL,  0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL,  0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF,       0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL,   0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL,   0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0,   0x43040319
+DATA 4, MX6_MMDC_P0_MPDGCTRL1,   0x03040279
+DATA 4, MX6_MMDC_P1_MPDGCTRL0,   0x43040321
+DATA 4, MX6_MMDC_P1_MPDGCTRL1,   0x03030251
+DATA 4, MX6_MMDC_P0_MPRDDLCTL,   0x4d434248
+DATA 4, MX6_MMDC_P1_MPRDDLCTL,   0x42413c4d
+DATA 4, MX6_MMDC_P0_MPWRDLCTL,   0x34424543
+DATA 4, MX6_MMDC_P1_MPWRDLCTL,   0x49324933
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001a0017
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00170027
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x000a001f
+DATA 4, MX6_MMDC_P0_MPMUR0,      0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0,      0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR,       0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR,       0x00011006
diff -Naur u-boot-imx/board/architech/tibidabo/clocks.cfg modificato-u-boot-imx/board/architech/tibidabo/clocks.cfg
--- u-boot-imx/board/architech/tibidabo/clocks.cfg	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/clocks.cfg	2015-02-03 17:00:46.115785596 +0100
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, CCM_CCOSR, 0x000000fb
diff -Naur u-boot-imx/board/architech/tibidabo/ddr-setup.cfg modificato-u-boot-imx/board/architech/tibidabo/ddr-setup.cfg
--- u-boot-imx/board/architech/tibidabo/ddr-setup.cfg	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/ddr-setup.cfg	2015-02-03 17:00:46.115785596 +0100
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q/MX6D ddr is limited to 1066 MHz currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ */
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+
+DATA 4, MX6_IOM_GRP_B0DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B1DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B2DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B3DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B4DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B5DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B6DS,  0x00000030
+DATA 4, MX6_IOM_GRP_B7DS,  0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_CAS,     0x00020030
+DATA 4, MX6_IOM_DRAM_RAS,     0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_RESET,  0x00020030
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
+
+/* (differential input) */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+/* (differential input) */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+/* disable ddr pullups */
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/*
+ * MDMISC	mirroring	interleaved (row/bank/col)
+ */
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00081740
+
+/*
+ * MDSCR	con_req
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff -Naur u-boot-imx/board/architech/tibidabo/Makefile modificato-u-boot-imx/board/architech/tibidabo/Makefile
--- u-boot-imx/board/architech/tibidabo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/Makefile	2015-02-03 18:19:12.196624156 +0100
@@ -0,0 +1,10 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := tibidabo.o
+
diff -Naur u-boot-imx/board/architech/tibidabo/tibidabo.c modificato-u-boot-imx/board/architech/tibidabo/tibidabo.c
--- u-boot-imx/board/architech/tibidabo/tibidabo.c	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/tibidabo.c	2015-02-04 17:42:29.644024349 +0100
@@ -0,0 +1,610 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+/*
+#include <asm/imx-common/iomux-v3.h>
+#include <common.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <micrel.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/mx6q_pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+*/
+/*
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+*/
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <malloc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+DECLARE_GLOBAL_DATA_PTR;
+
+extern void setup_i2c(unsigned i2c_index, int speed, int slave_addr, struct i2c_pads_info *p);
+/********************* uart *********************/
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |   \
+    PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |     \
+    PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+static iomux_v3_cfg_t
+    const uart2_pads[]      =
+{
+    MX6_PAD_EIM_D26__UART2_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+    MX6_PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+    imx_iomux_v3_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads));
+}
+
+/********************* mmc *********************/
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |    \
+    PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |     \
+    PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t
+    const usdhc3_pads[]     = 
+{
+    MX6_PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT5__GPIO7_IO00| MUX_PAD_CTRL(NO_PAD_CTRL),      /* CD */    
+};
+
+static struct fsl_esdhc_cfg
+    usdhc_cfg;
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+    struct fsl_esdhc_cfg
+        *cfg                = (struct fsl_esdhc_cfg *)mmc->priv;
+
+    if( cfg->esdhc_base == USDHC3_BASE_ADDR )
+    {
+        gpio_direction_input( IMX_GPIO_NR( 7, 0 ) );
+        return !gpio_get_value( IMX_GPIO_NR( 7, 0 ) );
+    }
+    else
+    {
+        return 1;
+    }
+}
+
+int board_mmc_init( bd_t *bis )
+{
+    usdhc_cfg.esdhc_base        = USDHC3_BASE_ADDR;
+    usdhc_cfg.sdhc_clk          = mxc_get_clock( MXC_ESDHC3_CLK );
+    usdhc_cfg.max_bus_width     = 4;
+    imx_iomux_v3_setup_multiple_pads( usdhc3_pads, ARRAY_SIZE(usdhc3_pads) );
+    return fsl_esdhc_initialize( bis, &usdhc_cfg );
+}
+
+/********************* spi flash *********************/
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |     \
+    PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+static iomux_v3_cfg_t
+    const ecspi1_pads[]         = 
+{
+    /* SS1 */
+    MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+};
+
+static void setup_spi(void)
+{
+    imx_iomux_v3_setup_multiple_pads( ecspi1_pads, ARRAY_SIZE( ecspi1_pads ) );
+}
+
+/********************* USB *************************/
+
+int board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	return 0;
+}
+
+/********************* network *********************/
+
+#define ENET_PAD_CTRL       (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t
+    const enet_pads1[]          =
+{
+    MX6_PAD_ENET_MDIO__ENET_MDIO        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_ENET_MDC__ENET_MDC          | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TXC__RGMII_TXC        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD0__RGMII_TD0        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD1__RGMII_TD1        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD2__RGMII_TD2        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD3__RGMII_TD3        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_ENET_REF_CLK__ENET_TX_CLK   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RXC__GPIO6_IO30       | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD0__GPIO6_IO25       | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD1__GPIO6_IO27       | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD2__GPIO6_IO28       | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD3__GPIO6_IO29       | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RX_CTL__GPIO6_IO24    | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_EIM_D23__GPIO3_IO23         | MUX_PAD_CTRL(NO_PAD_CTRL),            /* Chip nRST */
+    MX6_PAD_ENET_TX_EN__GPIO1_IO28      | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t
+    const enet_pads2[]          =
+{
+    MX6_PAD_RGMII_RXC__RGMII_RXC   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD0__RGMII_RD0   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD1__RGMII_RD1   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD2__RGMII_RD2   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD3__RGMII_RD3   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+    gpio_direction_input(  IMX_GPIO_NR( 1, 28 ) );                              /* Used to read when the switch registers can be accessed */
+    gpio_direction_output( IMX_GPIO_NR( 3, 23 ), 0 );                           /* RGMII reset */
+    gpio_direction_output( IMX_GPIO_NR( 6, 30 ), 1 );                           /* RGMII RXC - P5_GTXCLK/AM_DIS-in - Marvell Auto-Media Detect capable PHYs are not attached */
+
+    /*
+        P5_MODE[2:0] = 001 - Port 5 is configured to be in RGMII mode
+        (1000 Mbps, full-duplex only)
+    */
+    gpio_direction_output( IMX_GPIO_NR( 6, 25 ), 1 );                           /* RGMII RD0 - P5_MODE[0] */
+    gpio_direction_output( IMX_GPIO_NR( 6, 27 ), 0 );                           /* RGMII RD1 - P5_MODE[1] */
+    gpio_direction_output( IMX_GPIO_NR( 6, 28 ), 0 );                           /* RGMII RD2 - P5_MODE[2] */
+
+    imx_iomux_v3_setup_multiple_pads( enet_pads1, ARRAY_SIZE( enet_pads1 ) );   /* Initializing TX pads   */
+    gpio_direction_output( IMX_GPIO_NR( 6, 24 ), 1 );                           /* RGMI RX CTL            */
+    udelay( 10 );                                                               /* Tsu delay - Configuration data valid prior to RESETn de-asserted */
+    gpio_set_value( IMX_GPIO_NR( 3, 23 ), 1 );                                  /* De-asserting RESETn    */
+    imx_iomux_v3_setup_multiple_pads( enet_pads2, ARRAY_SIZE( enet_pads2 ) );   /* Initializing RX pads   */
+}
+
+static int wait_for_switch(void)
+{
+    uint32_t
+        start;
+    start                       = get_timer(0);
+    while( gpio_get_value( IMX_GPIO_NR( 1, 28 ) ) )
+    {
+        if( get_timer( start ) > 3000 )
+        {
+            printf( "The ethernet switch doesn't come up\n" );
+            return -1;
+        }
+    }
+    return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_enet();
+    if( wait_for_switch() )
+    {
+        printf( "Impossible to access mv88e6123 chip registers.\n" );
+        return 0;
+    }
+	ret                         = cpu_eth_init(bis);
+	if( ret )
+    {
+		printf("FEC MXC: %s:failed\n", __func__);
+    }
+	return ret;
+}
+
+static struct mv88e61xx_config 
+    swcfg               = 
+{
+    .name               = "FEC",
+    .vlancfg            = MV88E61XX_VLANCFG_ROUTER,                             /* you can configure it as MV88E61XX_VLANCFG_SWITCH as well */
+    .rgmii_delay        = MV88E61XX_RGMII_DELAY_EN,
+    .led_init           = MV88E61XX_LED_INIT_EN,
+    .mdip               = MV88E61XX_MDIP_NOCHANGE,
+    .portstate          = MV88E61XX_PORTSTT_FORWARDING,
+    .cpuport            = ( 1 << 5 ),
+    .ports_enabled      = ( 1 << 5 ) | ( 1 << 1 ) | ( 1 << 0 ),
+};
+
+void reset_phy(void)
+{
+    mv88e61xx_switch_initialize( &swcfg );
+}
+
+/********************* i2c *********************/
+
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP |              \
+    PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+    PAD_CTL_ODE       | PAD_CTL_SRE_FAST )
+
+#define PC              MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+/* I2C1 (SILICA LVDS/Raspberry Pi expansion) */
+static struct i2c_pads_info
+    i2c1_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_CSI0_DAT9__I2C1_SCL   | PC,
+        .gpio_mode      = MX6_PAD_CSI0_DAT9__GPIO5_IO27 | PC,
+        .gp             = IMX_GPIO_NR( 5, 27 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_CSI0_DAT8__I2C1_SDA   | PC,
+        .gpio_mode      = MX6_PAD_CSI0_DAT8__GPIO5_IO26 | PC,
+        .gp             = IMX_GPIO_NR( 5, 26 )
+    }
+};
+
+/* I2C2 (PMIC and HDMI) */
+static struct i2c_pads_info
+    i2c2_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_KEY_COL3__I2C2_SCL   | PC,
+        .gpio_mode      = MX6_PAD_KEY_COL3__GPIO4_IO12 | PC,
+        .gp             = IMX_GPIO_NR( 4, 12 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_KEY_ROW3__I2C2_SDA   | PC,
+        .gpio_mode      = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
+        .gp             = IMX_GPIO_NR( 4, 13 )
+    }
+};
+
+/* I2C3 (miniPCIe) */
+static struct i2c_pads_info
+    i2c3_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_GPIO_5__I2C3_SCL  | PC,
+        .gpio_mode      = MX6_PAD_GPIO_5__GPIO1_IO05 | PC,
+        .gp             = IMX_GPIO_NR( 1, 5 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_GPIO_6__I2C3_SDA  | PC,
+        .gpio_mode      = MX6_PAD_GPIO_6__GPIO1_IO06 | PC,
+        .gp             = IMX_GPIO_NR( 1, 6 )
+    }
+};
+
+static void setup_tibidabo_i2cs(void)
+{
+    setup_i2c( 0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c1_pads_info );
+    setup_i2c( 1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c2_pads_info );
+    setup_i2c( 2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c3_pads_info );
+}
+
+/********************* display *********************/
+
+struct display_info_t 
+{
+    int     bus;
+    int     addr;
+    int     pixfmt;
+    int     (*detect)(struct display_info_t const *dev);
+    void    (*enable)(struct display_info_t const *dev);
+    struct  fb_videomode mode;
+};
+
+static int detect_hdmi(struct display_info_t const *dev)
+{
+    struct hdmi_regs
+        *hdmi               = (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
+    return readb(&hdmi->phy_stat0) & HDMI_DVI_STAT;
+}
+
+static void enable_hdmi(struct display_info_t const *dev)
+{
+    imx_enable_hdmi_phy();
+}
+
+static struct display_info_t
+    const displays[]        = 
+{
+    {
+        .bus                = -1,
+        .addr               = 0,
+        .pixfmt             = IPU_PIX_FMT_RGB24,
+        .detect             = detect_hdmi,
+        .enable             = enable_hdmi,
+        .mode               = 
+        {
+            .name           = "HDMI",
+            .refresh        = 60,
+            .xres           = 1024,
+            .yres           = 768,
+            .pixclock       = 15385,
+            .left_margin    = 220,
+            .right_margin   = 40,
+            .upper_margin   = 21,
+            .lower_margin   = 7,
+            .hsync_len      = 60,
+            .vsync_len      = 10,
+            .sync           = FB_SYNC_EXT,
+            .vmode          = FB_VMODE_NONINTERLACED
+        } 
+    },
+};
+
+int board_video_skip(void)
+{
+    int
+        i,
+        ret;
+    char
+        const *panel        = getenv("panel");
+    if( !panel )
+    {
+        for( i = 0; i < ARRAY_SIZE( displays ); i++ )
+        {            
+            struct display_info_t
+                const *dev  = displays + i;
+            if( dev->detect && dev->detect( dev ) )
+            {
+                panel       = dev->mode.name;
+                printf( "auto-detected panel %s\n", panel );
+                break;
+            }
+        }
+        if( !panel )
+        {
+            panel           = displays[0].mode.name;
+            printf( "No panel detected: default to %s\n", panel );
+        }
+    }
+    else
+    {
+        for( i = 0; i < ARRAY_SIZE( displays ); i++ )
+        {
+            if( !strcmp( panel, displays[ i ].mode.name ) )
+            {
+                break;
+            }
+        }
+    }
+    if( i < ARRAY_SIZE( displays ) )
+    {
+        ret                 = ipuv3_fb_init( &displays[ i ].mode, 0, displays[ i ].pixfmt );
+        if( !ret )
+        {
+            displays[ i ].enable( displays + i );
+            printf( "Display: %s (%ux%u)\n", displays[ i ].mode.name, displays[ i ].mode.xres, displays[ i ].mode.yres );
+        }
+        else
+        {
+            printf( "LCD %s cannot be configured: %d\n", displays[ i ].mode.name, ret );
+        }
+    }
+    else
+    {
+        printf( "unsupported panel %s\n", panel );
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg
+        *mxc_ccm            = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc
+        *iomux              = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int
+        reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg                     = __raw_readl( &mxc_ccm->CCGR3 );
+	reg                     |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel( reg, &mxc_ccm->CCGR3 );
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg                     = readl( &mxc_ccm->cs2cdr );
+	reg                     &= ~( MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK );
+	reg                     |= ( 3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET ) | ( 3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET );
+	writel( reg, &mxc_ccm->cs2cdr );
+
+	reg                     = readl( &mxc_ccm->cscmr2 );
+	reg                     |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel( reg, &mxc_ccm->cscmr2 );
+
+	reg                     = readl( &mxc_ccm->chsccdr );
+	reg                     |= ( CHSCCDR_CLK_SEL_LDB_DI0 << MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET );
+	reg                     |= ( CHSCCDR_CLK_SEL_LDB_DI0 << MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET );
+	writel( reg, &mxc_ccm->chsccdr );
+
+	reg                     = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	                        | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	                        | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	                        | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	                        | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	                        | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	                        | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	                        | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	                        | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel( reg, &iomux->gpr[ 2 ] );
+
+	reg                     = readl( &iomux->gpr[ 3 ] );
+	reg                     = ( reg & ~( IOMUXC_GPR3_LVDS1_MUX_CTL_MASK | IOMUXC_GPR3_HDMI_MUX_CTL_MASK ) )
+	                        | ( IOMUXC_GPR3_MUX_SRC_IPU1_DI0 << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET );
+	writel( reg, &iomux->gpr[ 3 ] );
+}
+
+/********************* sata *********************/
+
+static int setup_sata(void)
+{
+	struct iomuxc_base_regs
+        *const iomuxc_regs  = (struct iomuxc_base_regs *) IOMUXC_BASE_ADDR;
+	int
+        ret                 = enable_sata_clock();
+	if( ret )
+    {
+		return ret;
+    }
+	clrsetbits_le32(
+                &iomuxc_regs->gpr[13],
+                IOMUXC_GPR13_SATA_MASK,
+                  IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB
+                | IOMUXC_GPR13_SATA_PHY_7_SATA2M
+                | IOMUXC_GPR13_SATA_SPEED_3G
+                | ( 3 << IOMUXC_GPR13_SATA_PHY_6_SHIFT )
+                | IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED
+                | IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_9_16
+                | IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P00_DB
+                | IOMUXC_GPR13_SATA_PHY_2_TX_1P104V
+                | IOMUXC_GPR13_SATA_PHY_1_SLOW
+            );
+
+	return 0;
+}
+
+/********************* information *********************/
+
+int checkboard(void)
+{
+    puts( "Board: Tibidabo\n" );
+    return 0;
+}
+
+int overwrite_console(void)
+{
+    return 1;
+}
+
+/********************* board init *********************/
+
+int dram_init(void)
+{
+    gd->ram_size                = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE); 
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    setup_iomux_uart();
+    setup_display();
+    return 0;
+}
+
+int board_init(void)
+{
+    gd->bd->bi_boot_params      = PHYS_SDRAM + 0x100;                       /* address of boot parameters */
+    setup_spi();
+    setup_tibidabo_i2cs();
+	setup_sata();
+    return 0;
+}
+
+int board_late_init(void)
+{
+    return 0;
+}
+
+int misc_init_r(void)
+{
+    return 0;
+}
diff -Naur u-boot-imx/board/architech/tibidabo/tibidabo.cfg modificato-u-boot-imx/board/architech/tibidabo/tibidabo.cfg
--- u-boot-imx/board/architech/tibidabo/tibidabo.cfg	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/board/architech/tibidabo/tibidabo.cfg	2015-02-04 11:52:21.804128663 +0100
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION   2
+
+/*
+ * Boot Device
+ */
+BOOT_FROM       spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "1066mhz_4x256mx16.cfg"
+#include "clocks.cfg"
diff -Naur u-boot-imx/boards.cfg modificato-u-boot-imx/boards.cfg
--- u-boot-imx/boards.cfg	2015-02-06 14:54:59.641155753 +0100
+++ modificato-u-boot-imx/boards.cfg	2015-02-03 16:55:38.775649254 +0100
@@ -1246,3 +1246,4 @@
 Orphan  powerpc     mpc8xx         -           -               mbx8xx              MBX                                  -                                                                                                                                 -
 Orphan  powerpc     mpc8xx         -           -               mbx8xx              MBX860T                              -                                                                                                                                 -
 Orphan  powerpc     mpc8xx         -           -               nx823               NX823                                -                                                                                                                                 -
+Active  arm         armv7          mx6         architech       tibidabo            tibidabo                             tibidabo:IMX_CONFIG=board/architech/tibidabo/tibidabo.cfg,MX6Q,DDR_MB=2048                                                        Alessandro Ratti <alessandro.ratti@silica.com>
diff -Naur u-boot-imx/drivers/net/phy/mv88e61xx.c modificato-u-boot-imx/drivers/net/phy/mv88e61xx.c
--- u-boot-imx/drivers/net/phy/mv88e61xx.c	2015-02-06 14:54:59.757155749 +0100
+++ modificato-u-boot-imx/drivers/net/phy/mv88e61xx.c	2015-02-03 16:41:35.374251886 +0100
@@ -415,8 +415,10 @@
 				return -1;
 			if (mv88361xx_reverse_mdipn(swconfig, phy))
 				return -1;
+#ifndef CONFIG_MACH_TIBIDABO 
 			if (mv88361xx_led_init(swconfig, phy))
 				return -1;
+#endif 
 		}
 
 		/* set port VID to port+1 except for cpu port */
diff -Naur u-boot-imx/include/configs/tibidabo.h modificato-u-boot-imx/include/configs/tibidabo.h
--- u-boot-imx/include/configs/tibidabo.h	1970-01-01 01:00:00.000000000 +0100
+++ modificato-u-boot-imx/include/configs/tibidabo.h	2015-02-04 17:55:59.273845924 +0100
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * Configuration settings for ArchiTech Tibidabo board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __TIBIDABO_CONFIG_H
+#define __TIBIDABO_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+#include <asm/sizes.h>
+#include "mx6_common.h"
+#include <config_cmd_default.h>
+
+/* Uncomment to print debug messages */
+/*#define DEBUG*/
+
+/* microcontroller family and machine definitions */
+#define CONFIG_MX6
+#define CONFIG_MACH_TYPE                       4822                         /* registered on www.arm.linux.org.uk/developer/machines */
+#define CONFIG_MACH_TIBIDABO
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C
+
+/* gets serial_mxc module compiled and linked and allows the use of UART2 (see board schematic) */
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE                    UART2_BASE
+
+/* parameters used to fill environment variables */
+#define FAKE_MAC_ADDRESS                        "66:55:44:33:22:11"         /* we need this to use the network interface but in production you have to blow the fuses */
+#define BOARD_IP_ADDRESS                        "192.168.0.1"               /* this will be our ip address during boot */
+#define TFTP_SERVER_IP_ADDRESS                  "192.168.0.100"             /* where to get the kernel image to boot with */
+#define TFTP_SERVER_NETMASK                     "255.255.255.0"             /* the netmask to use when looking for kernel image from remote */
+#define TFTP_SERVER_KERNEL_IMAGE                "uImage"                    /* kernel image filepath on the tftp server */
+#define SCRIPT_LOAD_ADDRESS                     "0x10008000"                /* where to place the read script */
+#define BOOT_SCRIPT_FILEPATH                    "/bootscript"               /* the filepath of the script containing information on how to boot */
+#define NETWORK_BOOT_SCRIPT_FILEPATH            "bootscript"                /* boot script path over the tftp server */
+
+/* physical memory map */
+#define CONFIG_NR_DRAM_BANKS                    1
+#define PHYS_SDRAM                              MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE                         (2u * 1024 * 1024 * 1024)   /* 2 GB of on-board DRAM memory */
+
+/* displays information */
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/* ensures that u-boot will boot the kernel with a command line tag that incorporates the kernel options set in "bootargs" environment variable */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool (heap size) */
+#define CONFIG_SYS_MALLOC_LEN                   (10 * 1024 * 1024)          /* 10 MB */
+
+/* enables initialization callbacks */
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOARD_LATE_INIT
+
+/* gets mxc_gpio module compiled and linked */
+#define CONFIG_MXC_GPIO
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR               0
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+
+/* filesystems related commands */
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+
+/* Add support for MS DOS partition tables */
+#define CONFIG_DOS_PARTITION
+
+/* serial flash configs */
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS                   0
+#define CONFIG_SF_DEFAULT_CS                    (0|(IMX_GPIO_NR(3, 19)<<8))
+#define CONFIG_SF_DEFAULT_SPEED                 20000000
+#define CONFIG_SF_DEFAULT_MODE                  (SPI_MODE_0)
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_CMD_SF_TEST
+#undef  CONFIG_CMD_IMLS                                                     /* we have a SPI flash so lets undefine the listing command of NOR and NAND flash memories */
+
+/* environment save configs */
+/*#define CONFIG_ENV_IS_IN_SPI_FLASH*/                                      /* uncomment this if you want to save the environment inside the flash memory */
+#define CONFIG_ENV_IS_IN_MMC                                                /* comment this out if you want to save the environment inside the flash memory */
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+    #define CONFIG_ENV_OFFSET                   (768 * 1024)
+    #define CONFIG_ENV_SECT_SIZE                (64  * 1024)
+    #define CONFIG_ENV_SPI_BUS                  CONFIG_SF_DEFAULT_BUS
+    #define CONFIG_ENV_SPI_CS                   CONFIG_SF_DEFAULT_CS
+    #define CONFIG_ENV_SPI_MODE                 CONFIG_SF_DEFAULT_MODE
+    #define CONFIG_ENV_SPI_MAX_HZ               CONFIG_SF_DEFAULT_SPEED   
+#elif defined(CONFIG_ENV_IS_IN_MMC)
+    #define CONFIG_SYS_MMC_ENV_DEV              0
+    #define CONFIG_ENV_OFFSET                   (6 * 64 * 1024)
+#endif
+
+/* SATA Configs */
+#define CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE              1
+#define CONFIG_DWC_AHSATA_PORT_ID               0
+#define CONFIG_DWC_AHSATA_BASE_ADDR             SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+
+/* network related stuff */
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE                            ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE                     RGMII
+#define CONFIG_ETHPRIME                         "FEC"
+#define CONFIG_FEC_MXC_PHYADDR                  5
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MARVELL
+#define CONFIG_MV88E61XX_CMD
+#define CONFIG_MV88E61XX_SWITCH
+#define CONFIG_RESET_PHY_R
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX                       1
+#define CONFIG_BAUDRATE                         115200
+
+/* fuses configs */
+#define CONFIG_CMD_FUSE
+#ifdef  CONFIG_CMD_FUSE
+    #define CONFIG_MXC_OCOTP
+#endif
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED                    100000
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_CMD_FAT
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_USB_ETHER_SMSC95XX
+#define CONFIG_MXC_USB_PORT                     1
+#define CONFIG_MXC_USB_PORTSC                   (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS                    0
+
+/* Framebuffer and LCD */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_IPUV3_CLK                        260000000
+#define CONFIG_IMX_HDMI
+
+/* boot stuff and load addresses */
+#define CONFIG_CMD_BMODE
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_BOOTDELAY                        2
+#define CONFIG_LOADADDR                         0x12000000
+#define CONFIG_SYS_LOAD_ADDR                    CONFIG_LOADADDR
+#define CONFIG_SYS_TEXT_BASE                    0x17800000
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+    "ethaddr=" FAKE_MAC_ADDRESS "\0" \
+    "ipaddr=" BOARD_IP_ADDRESS "\0" \
+    "serverip=" TFTP_SERVER_IP_ADDRESS "\0" \
+    "netmask=" TFTP_SERVER_KERNEL_IMAGE "\0" \
+    "bootfile=" TFTP_SERVER_KERNEL_IMAGE "\0" \
+    "script_load_address=" SCRIPT_LOAD_ADDRESS "\0" \
+    "bootscript_filepath=" BOOT_SCRIPT_FILEPATH "\0" \
+    "boot_from_sd=" \
+        "mmc dev 0 ; " \
+        "for partition in 1 2; do " \
+            "for fs in fat ext2 ; do " \
+                "${fs}load mmc 0:${partition} ${script_load_address} ${bootscript_filepath} && source ${script_load_address} ;" \
+            "done ;" \
+        "done ;\0" \
+    "boot_from_sata=" \
+        "sata device 0 ;" \
+        "for partition in 1 2; do " \
+            "for fs in fat ext2 ; do " \
+                "${fs}load sata 0:${partition} ${script_load_address} ${bootscript_filepath} && source ${script_load_address} ;" \
+            "done ;" \
+        "done ;\0" \
+    "ip_dyn=no\0" \
+    "tftp_bootscript_filepath=" NETWORK_BOOT_SCRIPT_FILEPATH "\0" \
+    "boot_from_network=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftpboot; " \
+		"fi; " \
+		"${get_cmd} ${script_load_address} ${tftp_bootscript_filepath} && source ${script_load_address} ; \0" \
+    "bootargs=console=ttymxc1,115200\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"run boot_from_sata; " \
+    "run boot_from_sd; " \
+    "run boot_from_network; " \
+    "echo Cannot boot from default locations; "
+
+#define CONFIG_ARP_TIMEOUT                      200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER                                              /* enables the extended command line version */
+#define CONFIG_SYS_PROMPT_HUSH_PS2              "> "                        /* prompt to print when more input is required */
+#define CONFIG_SYS_PROMPT                       "TIBIDABO U-Boot > "
+#define CONFIG_AUTO_COMPLETE                                                /* the shell will auto complete the commands if TAB key is pressed */
+#define CONFIG_SYS_CBSIZE                       256                         /* buffer size for console input */
+#define CONFIG_CMDLINE_EDITING                                              /* enables editing and history of the command line */
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE                       (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)        /* buffer size for console output */
+#define CONFIG_SYS_MAXARGS                      16                          /* max number of arguments accepted for monitor commands */
+#define CONFIG_SYS_BARGSIZE                     CONFIG_SYS_CBSIZE           /* buffer size for the linux kernel arguments */
+
+/* Memory area used by simple memory test */
+#define CONFIG_SYS_MEMTEST_START                0x10000000
+#define CONFIG_SYS_MEMTEST_END                  0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH              0x10800000
+
+/* frequency of timer */
+#define CONFIG_SYS_HZ                           1000                        
+
+
+/* initial memory setup */
+#define CONFIG_SYS_SDRAM_BASE                   PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR                IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE                IRAM_SIZE
+#define CONFIG_SYS_INIT_SP_OFFSET               (CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR                 (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE                         (8 * 1024)
+
+#define CONFIG_OF_LIBFDT
+
+#endif /* __TIBIDABO_CONFIG_H */
